#!/bin/sh

# WARNING!!
#
# While I put a bit of effort into making this as safe to use as I know how,
# this is probably not safe for generating actual passwords because I am not an
# infosec specialist. In plain terms:
#
###############################
#    USE AT YOUR OWN RISK!    #
###############################

# NOTE: While this script is mostly POSIX compliant, it may depend on tools from
# GNU Coreutils. I intend to test it further at a later date. -- cjb, 2019-03

cntr=0
# we don't include 0 as a easy hack to not get 00 through 09, although we don't
# get 10,20,30,.. etc etc. this saves us an if statement, and shouldn't be a
# security issue.
stop=$(tr -dc '1-9' < /dev/urandom | fold -w 2 | head -n1)

while [ "$cntr" -le "$stop" ]
do
    l=$(tr -dc '0-9' < /dev/urandom | fold -w 2 | head -n1)
    # hack to make 04 == 4, or 05 == 5. NOTE: we ignore shellcheck's SC2003
    # because in this case $(( )) is *not* what we want.
    # shellcheck disable=SC2003
    l=$(expr "$l" + 0)
    if [ "$l" -ge 15 ] && [ "$l" -le 40 ]
    then
        # *supposedly* some organisations such as the NSA can figure out the
        # first x amount of lines of /dev/urandom, so we pass a list of
        # characters to head -n $l multiplied by itself 3 times to get a random
        # *amount* of characters, and tail that to get a random length after we
        # remove the '\n's with tr.
        strings < /dev/urandom | grep -o '[0-9A-Za-z~!@#$%^&*()_+]' | head -n $(( l*l*l )) | tail -n "$l" | tr -d '\n'
        printf '\n'
        # increment the counter
        cntr=$(( cntr + 1 ))
    fi
done
