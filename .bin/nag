#!/bin/bash -ueE
## Problem: I forget to file timesheets, and I'm easily distracted
## such that I forget WHEN I changed from working on ticket N to
## working on ticket M.
##
## Therefore, run this from a crontab every fifteen minutes.  It will
## pop up an editor in my screen session, prompting me to write down
## what I'm doing RIGHT NOW.
##
## Do nothing if the previous popup is still open, so that after being
## AFK I don't return to a session with hundreds of popups.
##
## FIXME: use sqlite or tokyocabinet so backdated timestamps will be
## sorted correctly.

# Override this by setting $nag_timelog as an environment variable, or
# using the -f option.
timelog="${nag_timelog:-$HOME/.nag/timelog}"

while getopts "hpd:f:" opt
do  case "$opt" in
        d)  date=$OPTARG;;
        f)  timelog="$OPTARG";;
        p)                      # cron is trying to popup a window.
	    test -n "$(find /dev/tty?* /dev/pts -user "$EUID" -mmin -14 -print -quit)"
            ## This is broken by improvements to the office network.
	    #getent hosts soy >/dev/null
            exec tmux new-window nag
            ;;
        h|'?')
            echo "Usage: nag [ -f nagLogFilename ] [ -p | [-dDATE] [MESSAGE] ]"
            echo "In your crontab, try:"
            echo "    */15 *  * * *  nag -p"
            exit 1;;
    esac
done
shift $((${OPTIND:-1}-1))

now="$(date -d"${date-now}" --rfc-3339 seconds)"

# Create the directory inside which the timelog should live if it
# doesn't exist
[ ! -d ${timelog%/*} ] && mkdir -p ${timelog%/*}

# Change to the directory. This is required to check for the presence of
# a Git repository
cd ${timelog%/*}

# If this is a git repository (FIXME: surely there's a better way to
# test this), attempt to pull any updates from the master.
# FIXME: This will likely break if the remote Git repo can't be
# contacted, or if there are merge conflicts.
git status &> /dev/null && git pull > /dev/null

if test 0 -eq $#
then
    if type toilet  >/dev/null 2>&1
    then
      toilet -tffuture "What are you doing?!"
    else
      echo "WHAT ARE YOU DOING?!"
    fi
    if test -f "$timelog"
    then
        tail "$timelog"
        old=$(sed -rn '$ s/^.{26}//p' "$timelog")

        # Allocate new history file and delete it on exit.
        HISTFILE=$(mktemp -t nag.XXXXXX)
        trap "rm -f \"$HISTFILE\"" 0 TERM ERR QUIT

        # Store a single copy of all unique entries in history file.
        sed -rn 's/^.{26}//p' "$timelog" | uniq > $HISTFILE
        history -c                      # Clear all current history.
        history -n                      # Read everything from history file.
    fi
    read -ep "$now " -i "${old-}" response
    set -- "$response"
fi

echo "$now $*" >>"$timelog"

# Sort the timelog so I don't have to do it manually later.
sort "$timelog" > "$timelog.tmp"; mv "$timelog.tmp" "$timelog"

# Copy to shell.
rsync -a ~/.nag/ login.cyber.com.au:.nag/
